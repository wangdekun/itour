'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _uxcoreCellField = require('uxcore-cell-field');

var _uxcoreCellField2 = _interopRequireDefault(_uxcoreCellField);

var _uxcorePagination = require('uxcore-pagination');

var _uxcorePagination2 = _interopRequireDefault(_uxcorePagination);

var _uxcoreConst = require('uxcore-const');

var _uxcoreConst2 = _interopRequireDefault(_uxcoreConst);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _upperFirst = require('lodash/upperFirst');

var _upperFirst2 = _interopRequireDefault(_upperFirst);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _classnames2 = require('classnames');

var _classnames3 = _interopRequireDefault(_classnames2);

var _nattyFetch = require('natty-fetch');

var _nattyFetch2 = _interopRequireDefault(_nattyFetch);

var _lie = require('lie');

var _lie2 = _interopRequireDefault(_lie);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _uxcoreAnimate = require('uxcore-animate');

var _uxcoreAnimate2 = _interopRequireDefault(_uxcoreAnimate);

var _class = require('rc-util/lib/Dom/class');

var _css = require('rc-util/lib/Dom/css');

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _Mask = require('./Mask');

var _Mask2 = _interopRequireDefault(_Mask);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _Header = require('./Header');

var _Header2 = _interopRequireDefault(_Header);

var _Footer = require('./Footer');

var _Footer2 = _interopRequireDefault(_Footer);

var _Tbody = require('./Tbody');

var _Tbody2 = _interopRequireDefault(_Tbody);

var _ActionBar = require('./ActionBar');

var _ActionBar2 = _interopRequireDefault(_ActionBar);

var _methods = require('./methods');

var _methods2 = _interopRequireDefault(_methods);

var _innerMethods = require('./innerMethods');

var _innerMethods2 = _interopRequireDefault(_innerMethods);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Table Component for uxcore
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author zhouquan.yezq
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * Copyright 2014-2015, UXCore Team, Alinw.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

var createCellField = _uxcoreCellField2["default"].createCellField;

var getStyle = _css.get;

var Table = function (_React$Component) {
  _inherits(Table, _React$Component);

  function Table(props) {
    _classCallCheck(this, Table);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

    _this.bindInnerMethods();
    _this.uid = 0;
    _this.fields = {};
    _this.copyData = (0, _cloneDeep2["default"])(_this.props.jsxdata);
    _this.hasFixed = _util2["default"].hasFixColumn(props);
    _this.data = _this.addValuesInData((0, _cloneDeep2["default"])(_this.props.jsxdata));
    _this.state = {
      data: _this.data, // checkbox 内部交互
      columns: _this.processColumn(), // column 内部交互
      showMask: props.showMask, // fetchData 时的内部状态改变
      pageSize: props.pageSize, // pagination 相关
      currentPage: props.currentPage, // pagination 相关
      activeColumn: null,
      searchTxt: '',
      expandedKeys: []
    };
    _this.handleBodyScroll = _this.handleBodyScroll.bind(_this);
    _this.handleHeaderScroll = _this.handleHeaderScroll.bind(_this);
    _this.changeSelected = _this.changeSelected.bind(_this);
    _this.handleDataChange = _this.handleDataChange.bind(_this);
    _this.attachCellField = _this.attachCellField.bind(_this);
    _this.detachCellField = _this.detachCellField.bind(_this);
    _this.selectAll = _this.selectAll.bind(_this);
    _this.handleOrderColumnCB = _this.handleOrderColumnCB.bind(_this);
    _this.handleColumnPickerChange = _this.handleColumnPickerChange.bind(_this);
    _this.handleActionBarSearch = _this.handleActionBarSearch.bind(_this);
    return _this;
  }

  Table.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var me = this;
    if (!!me.state.data && !!me.state.data.datas) {
      console.warn('Table: "content.data" rather than "content.datas" is recommended, ' + 'the support for "content.datas" will be end from ver. 1.5.0');
    }
    if (me.props.subComp) {
      console.warn('Table: subComp is deprecated, use renderSubComp instead.');
    }
    if (me.props.renderSubComp && this.hasFixed) {
      console.warn('Table: subComp cannot be rendered if fixed column exists, remove fixed column or props.renderSubComp');
    }
    if (this.props.fetchDataOnMount) {
      this.fetchData();
    }
    this.bindMethods();
    this.resizeListener = this.listenWindowResize();
    if (this.root) {
      this.rootWidth = this.root.clientWidth;
    }
    if (this.hasPercentWidth) {
      setTimeout(function () {
        _this2.setState({
          columns: _this2.processColumn()
        }, function () {
          _this2.checkRightFixed(true);
        });
      }, 200);
    }
  };

  Table.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var me = this;
    var newData = {};
    if (nextProps.jsxdata && !(0, _isEqual2["default"])(nextProps.jsxdata, this.copyData)) {
      // Data has changed, so uid which is used to mark the data should be reset.
      me.uid = 0;
      me.fetchData('dataChange', nextProps);
      // TODO: need reduce times
      this.forceToCheckRight = true;
    }
    if (nextProps.pageSize !== me.props.pageSize) {
      newData.pageSize = nextProps.pageSize;
    }
    if (nextProps.currentPage !== me.props.currentPage) {
      newData.currentPage = nextProps.currentPage;
    }
    if (!!nextProps.jsxcolumns && !(0, _isEqual2["default"])(nextProps.jsxcolumns, me.props.jsxcolumns)) {
      newData.columns = me.processColumn(nextProps);
      this.hasFixed = _util2["default"].hasFixColumn(nextProps);
    }
    if (nextProps.showMask !== me.props.showMask) {
      newData.showMask = nextProps.showMask;
    }
    if (nextProps.fetchUrl !== me.props.fetchUrl || !(0, _isEqual2["default"])(nextProps.fetchParams, me.props.fetchParams)) {
      me.fetchData('propsChange', nextProps);
    }
    me.setState(newData);
  };

  Table.prototype.componentDidUpdate = function componentDidUpdate() {
    // TODO: performance need to be cared
    this.checkBodyVScroll();
    this.checkBodyHScroll();
    this.checkRightFixed(this.forceToCheckRight);
    this.forceToCheckRight = false;
  };

  Table.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.resizeListener) {
      this.resizeListener.remove();
    }
  };

  /**
   * register CellField to Table for the global validation
   * @param field {element} the cell field to be registered
   */

  Table.prototype.attachCellField = function attachCellField(validate, name) {
    var me = this;
    if (!name) {
      console.error('Table: dataKey can not be undefined, check the column config');
    } else {
      me.fields[name] = validate;
    }
  };

  Table.prototype.bindInnerMethods = function bindInnerMethods() {
    var me = this;
    Object.keys(_innerMethods2["default"]).forEach(function (key) {
      me[key] = _innerMethods2["default"][key].bind(me);
    });
  };

  Table.prototype.bindMethods = function bindMethods() {
    var me = this;
    Object.keys(_methods2["default"]).forEach(function (key) {
      me[key] = _methods2["default"][key].bind(me);
    });
  };

  /**
   * change SelectedRows data via checkbox, this function will pass to the Cell
   * @param checked {boolean} the checkbox status
   * @param rowIndex {number} the row Index
   * @param fromMount {boolean} onSelect is called from cell Mount is not expected.
   */

  Table.prototype.changeSelected = function changeSelected(checked, rowIndex, fromMount) {
    var me = this;
    var content = (0, _cloneDeep2["default"])(this.state.data);
    var _data = content.datas || content.data;

    if (me.checkboxColumn.type === 'radioSelector') {
      for (var i = 0; i < _data.length; i++) {
        var item = _data[i];
        if (item.jsxid === rowIndex) {
          item[me.checkboxColumnKey] = checked;
        } else if (item[me.checkboxColumnKey]) {
          item[me.checkboxColumnKey] = false;
        }
      }
    } else {
      for (var _i = 0; _i < _data.length; _i++) {
        var _item = _data[_i];
        if (_item.jsxid === rowIndex) {
          _item[me.checkboxColumnKey] = checked;
          break;
        }
      }
    }

    me.setState({
      data: content
    }, function () {
      if (!fromMount) {
        var data = me.state.data.datas || me.state.data.data;
        var selectedRows = data.filter(function (item) {
          return item[me.checkboxColumnKey] === true;
        });
        if (me.props.rowSelection && me.props.rowSelection.onSelect) {
          me.props.rowSelection.onSelect(checked, data[rowIndex], selectedRows);
        }
      }
    });
  };

  /**
   * change the checkboxColumnKey of data, passed to the Row
   * @param checked {boolean} tree checkbox status
   * @param dataIndex {string} like `1-2-3` means the position of the Row in data
   */


  Table.prototype.changeTreeSelected = function changeTreeSelected(checked, dataIndex) {
    var me = this;
    var currentLevel = dataIndex.toString().split('-');
    var levelDepth = currentLevel.length;
    var data = (0, _cloneDeep2["default"])(me.state.data);
    var current = data.data;
    // record each tree node for reverse recursion.
    var treeMap = [];
    for (var i = 0; i < levelDepth - 1; i++) {
      treeMap[i] = current;
      current = current[currentLevel[i]].data;
    }
    // check/uncheck current row and all its children
    current = current[currentLevel[levelDepth - 1]];
    current[me.checkboxColumnKey] = checked;
    _util2["default"].changeValueR(current, me.checkboxColumnKey, checked);

    // reverse recursion, check/uncheck parents by its children.
    for (var _i2 = treeMap.length - 1; _i2 >= 0; _i2--) {
      treeMap[_i2][currentLevel[_i2]][me.checkboxColumnKey] = treeMap[_i2][currentLevel[_i2]].data.every(function (item) {
        return item[me.checkboxColumnKey] === true;
      });
    }

    me.setState({
      data: data
    }, function () {
      var selectedRows = _util2["default"].getAllSelectedRows((0, _cloneDeep2["default"])(data), me.checkboxColumnKey);
      if (me.props.rowSelection && me.props.rowSelection.onSelect) {
        me.props.rowSelection.onSelect(checked, current, selectedRows);
      }
    });
  };

  /**
   * check if right fixed table is needed.
   * if table is wide enough, hide the right fixed.
   * @param force force to check
   */


  Table.prototype.checkRightFixed = function checkRightFixed(force) {
    if (this.rightFixedTable) {
      var headerScroll = this.headerScroll;
      var headerScrollDom = headerScroll.getDom();
      if (force !== true && this.cachedHeaderScrollWidth === headerScrollDom.clientWidth) {
        return;
      }
      var headerScrollInner = headerScroll.getScroller();
      this.cachedHeaderScrollWidth = headerScrollDom.clientWidth;
      if (headerScrollInner.clientWidth === headerScrollDom.clientWidth && getStyle(this.rightFixedTable, 'display') === 'block') {
        this.rightFixedTable.style.display = 'none';
      } else if (headerScrollInner.clientWidth > headerScrollDom.clientWidth && getStyle(this.rightFixedTable, 'display') === 'none') {
        this.rightFixedTable.style.display = 'block';
      }
    }
  };

  /**
   * hide vertical scrollbar if table is not vertically scrollable
   */


  Table.prototype.checkBodyVScroll = function checkBodyVScroll() {
    if (this.bodyScroll) {
      var prefixCls = this.props.prefixCls;

      var node = this.bodyScroll.getDom();
      // body does not exist if no data
      if (node.children[0]) {
        var wrapperHeight = node.clientHeight;
        var bodyHeight = node.children[0].clientHeight;
        var headerDom = this.headerScroll ? this.headerScroll.getDom() : null;
        var footerDom = this.footerScroll ? this.footerScroll.getDom() : null;
        var noVScroll = bodyHeight <= wrapperHeight;
        if (this.noVScroll === undefined || this.noVScroll !== noVScroll) {
          if (noVScroll) {
            (0, _class.addClass)(node, prefixCls + '-no-v-scroll');
            if (headerDom) {
              (0, _class.addClass)(headerDom, prefixCls + '-no-v-scroll');
            }
            if (footerDom) {
              (0, _class.addClass)(footerDom, prefixCls + '-no-v-scroll');
            }
          } else {
            (0, _class.removeClass)(node, prefixCls + '-no-v-scroll');
            if (headerDom) {
              (0, _class.removeClass)(headerDom, prefixCls + '-no-v-scroll');
            }
            if (footerDom) {
              (0, _class.removeClass)(footerDom, prefixCls + '-no-v-scroll');
            }
          }
          this.noVScroll = noVScroll;
        }
      }
    }
  };
  /**
   * add fixed body box-shadow when body is scrolling horizontally
   * @param {number} scrollLeft body's current scrollLeft
   */


  Table.prototype.checkBodyHScroll = function checkBodyHScroll(scrollLeft) {
    if (!this.hasFixed) {
      return false;
    }
    var node = this.bodyScroll.getDom();
    var wrapperScrollLeft = scrollLeft || node.scrollLeft;
    if (this.hasFixed.hasLeft && this.fixedTable) {
      if (wrapperScrollLeft > 0) {
        (0, _class.addClass)(this.fixedTable, 'has-scroll');
      } else {
        (0, _class.removeClass)(this.fixedTable, 'has-scroll');
      }
    }
    if (this.hasFixed.hasRight) {
      var wrapperWidth = node.clientWidth;
      if (node.children[0]) {
        var bodyWidth = node.children[0].clientWidth;
        if (this.rightFixedTable) {
          if (wrapperScrollLeft + wrapperWidth + 3 < bodyWidth) {
            (0, _class.addClass)(this.rightFixedTable, 'end-of-scroll');
          } else {
            (0, _class.removeClass)(this.rightFixedTable, 'end-of-scroll');
          }
        }
      }
    }
    return false;
  };

  /**
   * cancel the CellField when it is unmounted.
   * @param {element} field  the cell field to be canceled.
   */

  Table.prototype.detachCellField = function detachCellField(name) {
    delete this.fields[name];
  };

  /**
   * fetch Data via Ajax
   * @param {string} from tell fetchData where it is invoked, the param will be
   * passed to props.beforeFetch in order to help the user.
   */

  Table.prototype.fetchData = function fetchData(from, nextProps, cb) {
    var me = this;
    var props = nextProps || this.props;
    // reset uid cause table data has changed
    me.uid = 0;

    // fetchUrl has the top priority.
    if (props.fetchUrl) {
      me.fetchRemoteData(from, props, cb);
    } else if (props.passedData) {
      me.fetchPassedData(props, cb);
    } else if (props.jsxdata) {
      me.fetchLocalData(from, props, cb);
    } else {
      // default will create one row
      var data = {
        data: [{
          jsxid: me.uid,
          __mode__: _uxcoreConst2["default"].MODE.EDIT
        }],
        currentPage: 1,
        totalCount: 0
      };
      me.uid += 1;
      me.data = data;
      me.setState({
        data: data
      });
    }
  };

  Table.prototype.fetchRemoteData = function fetchRemoteData(from, props) {
    var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

    var me = this;
    if (me.request) {
      me.request.abort();
    }
    if (!me.state.showMask) {
      me.setState({
        showMask: true
      });
    }

    var isJsonp = props.isJsonp === undefined ? /\.jsonp/.test(props.fetchUrl) : props.isJsonp;
    me.request = _nattyFetch2["default"].create({
      method: props.fetchMethod,
      url: props.fetchUrl,
      data: me.getQueryObj(from, props),
      fit: props.fitResponse,
      withCredentials: props.fetchWithCredentials,
      jsonp: isJsonp,
      Promise: _lie2["default"]
    });

    me.request().then(function (content) {
      var processedData = me.addValuesInData(props.processData((0, _cloneDeep2["default"])(content))) || {};
      var updateObj = {
        data: processedData,
        showMask: false
      };
      var resetExpandedKeys = props.shouldResetExpandedKeys(from) !== false;
      if (resetExpandedKeys) {
        updateObj.expandedKeys = _util2["default"].getDefaultExpandedKeys(processedData.data, props.levels);
      }
      if (processedData.currentPage !== undefined) {
        updateObj.currentPage = processedData.currentPage;
      }
      me.data = (0, _cloneDeep2["default"])(processedData);
      me.setState(updateObj, function () {
        cb();
      });
    })["catch"](function (err) {
      props.onFetchError(err);
      me.setState({
        data: {
          data: []
        },
        showMask: false
      });
    });
  };

  Table.prototype.fetchPassedData = function fetchPassedData(props) {
    var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

    console.warn('props subComp is deprecated, use renderSubComp instead.');
    var me = this;
    if (!props.queryKeys) {
      var data = me.addValuesInData(props.processData((0, _cloneDeep2["default"])(props.passedData)));
      me.setState({
        data: data
      });
      me.data = (0, _cloneDeep2["default"])(data);
    } else {
      var _data2 = {};
      props.queryKeys.forEach(function (key) {
        if (props.passedData[key] !== undefined) {
          _data2[key] = props.passedData[key];
        }
      });
      var processedData = me.addValuesInData(props.processData((0, _cloneDeep2["default"])(_data2)));
      me.data = (0, _cloneDeep2["default"])(processedData);
      me.setState({
        data: processedData
      }, function () {
        cb();
      });
    }
  };

  Table.prototype.fetchLocalData = function fetchLocalData(from, props) {
    var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

    var me = this;
    if (['pagination', 'order', 'search'].indexOf(from) !== -1) {
      if (from === 'pagination' && props.onPagerChange) {
        props.onPagerChange(me.state.currentPage, me.state.pageSize);
      }

      if (from === 'order' && props.onOrder) {
        props.onOrder(me.state.activeColumn, me.state.orderType);
      }

      if (from === 'search' && props.onSearch) {
        props.onSearch(me.state.searchTxt);
      }
    } else {
      this.copyData = (0, _cloneDeep2["default"])(props.jsxdata);
      var data = this.addValuesInData((0, _cloneDeep2["default"])(props.jsxdata));
      var currentPage = data && data.currentPage || this.state.currentPage;
      this.data = (0, _cloneDeep2["default"])(data);
      var updateObj = {
        data: data,
        currentPage: currentPage
      };
      var resetExpandedKeys = props.shouldResetExpandedKeys(from) !== false;
      if (resetExpandedKeys) {
        updateObj.expandedKeys = _util2["default"].getDefaultExpandedKeys(data.data, props.levels);
      }
      this.setState(updateObj, function () {
        cb();
      });
    }
  };

  /**
   * get Query Object by combining data from searchBar, column order, pagination
   * and fetchParams.
   * @param {string} from used in props.beforeFetch
   */

  Table.prototype.getQueryObj = function getQueryObj(from, props) {
    var me = this;
    var queryObj = {};
    if (props.passedData) {
      var queryKeys = props.queryKeys;
      if (!queryKeys) {
        queryObj = props.passedData;
      } else {
        queryKeys.forEach(function (key) {
          if (props.passedData[key] !== undefined) {
            queryObj[key] = props.passedData[key];
          }
        });
      }
    }

    // pagination
    queryObj = (0, _objectAssign2["default"])({}, queryObj, {
      pageSize: me.state.pageSize,
      currentPage: me.state.currentPage
    });

    // column order
    var activeColumn = me.state.activeColumn;
    var orderType = me.state.orderType;
    if (activeColumn) {
      queryObj = (0, _objectAssign2["default"])({}, queryObj, {
        orderColumn: activeColumn.dataKey
      });
      if (orderType && orderType !== 'none') {
        queryObj.orderType = orderType;
      }
    }

    // search query
    var searchTxt = me.state.searchTxt;
    if (searchTxt) {
      queryObj = (0, _objectAssign2["default"])({}, queryObj, {
        searchTxt: searchTxt
      });
    }

    // fetchParams has the top priority
    if (props.fetchParams) {
      queryObj = (0, _objectAssign2["default"])({}, queryObj, props.fetchParams);
    }

    return props.beforeFetch((0, _cloneDeep2["default"])(queryObj), from);
  };

  Table.prototype.getCheckStatus = function getCheckStatus(data) {
    var me = this;
    var rowSelection = me.props.rowSelection;

    var column = me.checkboxColumn;
    if (!column || data.length === 0) {
      return false;
    }
    var checkboxColumnKey = me.checkboxColumnKey;
    var isAllDisabled = true;
    var isHalfChecked = false;
    var checkedColumn = 0;
    var enabledColumn = 0;
    for (var i = 0; i < data.length; i++) {
      var item = data[i];
      if (!column.disable && !(column.isDisable && column.isDisable(item)) && !((typeof rowSelection === 'undefined' ? 'undefined' : _typeof(rowSelection)) === 'object' && rowSelection.isDisabled && rowSelection.isDisabled(item))) {
        isAllDisabled = false;
        enabledColumn += 1;
        if (item[checkboxColumnKey]) {
          isHalfChecked = true;
          checkedColumn += 1;
        }
      }
    }
    var isAllChecked = enabledColumn ? checkedColumn === enabledColumn : false;
    return { isAllChecked: isAllChecked, isAllDisabled: isAllDisabled, isHalfChecked: isAllChecked ? false : isHalfChecked };
  };

  Table.prototype.getDom = function getDom() {
    return this.root;
  };

  Table.prototype.getMainBody = function getMainBody() {
    return this.bodyScroll;
  };

  Table.prototype.getPager = function getPager() {
    return this.pager;
  };

  Table.prototype.handleRowHover = function handleRowHover(index, isEnter) {
    var _this3 = this;

    if (!isEnter) {
      this.rowHoverTimer = setTimeout(function () {
        _this3.setState({
          currentHoverRow: -1
        });
      }, 100);
    } else {
      if (this.rowHoverTimer) {
        clearTimeout(this.rowHoverTimer);
        this.rowHoverTimer = null;
      }
      this.setState({
        currentHoverRow: index
      });
    }
  };

  Table.prototype.handleShowSizeChange = function handleShowSizeChange(current, pageSize) {
    var me = this;
    me.setState({
      currentPage: current,
      pageSize: pageSize
    }, function () {
      me.fetchData('pagination');
    });
  };

  Table.prototype.handleColumnPickerChange = function handleColumnPickerChange(checkedKeys, groupName) {
    var _this4 = this;

    var columns = (0, _cloneDeep2["default"])(this.state.columns);
    var notRenderColumns = ['jsxchecked', 'jsxtreeIcon', 'jsxwhite'];
    notRenderColumns.push(this.checkboxColumnKey);
    var commonGroupName = _util2["default"].getConsts().commonGroup;
    for (var i = 0; i < columns.length; i++) {
      var item = columns[i];
      var isGroup = {}.hasOwnProperty.call(item, 'columns') && _typeof(item.columns) === 'object';
      // current column is a group and groupName is right
      if (isGroup && item.group === groupName) {
        for (var j = 0; j < item.columns.length; j++) {
          var ele = item.columns[j];
          if (checkedKeys.indexOf(ele.dataKey) !== -1) {
            ele.hidden = false;
          } else {
            ele.hidden = true;
          }
        }
        break;
      } else if (groupName === commonGroupName && item.group === undefined) {
        // current column is common group
        if (checkedKeys.indexOf(item.dataKey) !== -1 || notRenderColumns.indexOf(item.dataKey) !== -1 || item.type === 'action') {
          item.hidden = false;
        } else {
          item.hidden = true;
        }
      }
    }

    var selectedKeys = _util2["default"].getSelectedKeys(columns);

    if (selectedKeys.length === 0) {
      return;
    }

    this.setState({
      columns: columns
    }, function () {
      if (typeof _this4.props.onColumnPick === 'function') {
        _this4.props.onColumnPick((0, _cloneDeep2["default"])(columns));
      }
      _this4.checkRightFixed(true);
    });
  };

  Table.prototype.handleBodyScroll = function handleBodyScroll(scrollLeft, scrollTop, column) {
    this.bodyIsScorlling = true;
    if (this.headerIsScrolling) {
      this.headerIsScrolling = false;
      return;
    }
    if (this.footerIsScorlling) {
      this.footerIsScorlling = false;
      return;
    }
    var me = this;
    if (scrollLeft !== undefined && column === 'scroll') {
      var headerNode = me.headerScroll;
      var footerNode = me.footerScroll;
      if (headerNode) {
        headerNode.getDom().scrollLeft = scrollLeft;
      }
      if (footerNode) {
        footerNode.getDom().scrollLeft = scrollLeft;
      }
    }
    if (scrollTop !== undefined && this.hasFixed) {
      var columnType = ['fixed', 'rightFixed', 'scroll'];
      var columnToScroll = columnType.filter(function (item) {
        return item !== column;
      });
      columnToScroll.forEach(function (item) {
        var instance = me['body' + (0, _upperFirst2["default"])(item)];
        if (instance) {
          instance.getDom().scrollTop = scrollTop;
        }
      });
    }
    me.checkBodyHScroll(scrollLeft);
  };

  Table.prototype.handleHeaderScroll = function handleHeaderScroll(scrollLeft) {
    this.headerIsScrolling = true;
    if (this.bodyIsScorlling) {
      this.bodyIsScorlling = false;
      return;
    }
    if (this.footerIsScorlling) {
      this.footerIsScorlling = false;
      return;
    }
    if (scrollLeft !== undefined) {
      var me = this;
      var bodyNode = me.bodyScroll;
      bodyNode.getDom().scrollLeft = scrollLeft;
      var footerDom = me.footerScroll ? me.footerScroll.getDom() : null;
      if (footerDom) {
        footerDom.scrollLeft = scrollLeft;
      }
    }
  };

  Table.prototype.handleFooterScroll = function handleFooterScroll(scrollLeft) {
    this.footerIsScrolling = true;
    if (this.bodyIsScorlling) {
      this.bodyIsScorlling = false;
      return;
    }
    if (this.headerIsScrolling) {
      this.headerIsScrolling = false;
      return;
    }

    if (scrollLeft !== undefined) {
      var me = this;
      var bodyNode = me.bodyScroll;
      bodyNode.getDom().scrollLeft = scrollLeft;
      var headerDom = me.headerScrol ? me.headerScrol.getDom() : null;
      if (headerDom) {
        headerDom.scrollLeft = scrollLeft;
      }
    }
  };

  Table.prototype.handleOrderColumnCB = function handleOrderColumnCB(type, column) {
    var me = this;
    me.setState({
      activeColumn: column,
      orderType: type
    }, function () {
      me.fetchData('order');
    });
  };

  Table.prototype.handleActionBarSearch = function handleActionBarSearch(value) {
    var me = this;
    this.setState({
      searchTxt: value
    }, function () {
      me.fetchData('search');
    });
  };

  /**
   * For inline edit
   * receive changes from cell field and change state.data
   * inform users of the change with dataKey & pass
   */

  Table.prototype.handleDataChange = function handleDataChange(obj) {
    var me = this;
    var jsxid = obj.jsxid,
        column = obj.column,
        value = obj.value,
        text = obj.text,
        pass = obj.pass;

    var dataKey = column.dataKey;
    var editKey = column.editKey || dataKey;
    var data = (0, _cloneDeep2["default"])(me.state.data);
    var changedData = {};
    for (var i = 0; i < data.data.length; i++) {
      if (data.data[i].jsxid === jsxid) {
        data.data[i][dataKey] = text;
        data.data[i][editKey] = value;
        changedData = data.data[i];
      }
    }

    me.setState({
      data: data
    }, function () {
      me.props.onChange({
        data: me.state.data,
        editKey: editKey,
        dataKey: dataKey,
        changedData: changedData,
        pass: pass
      });
    });
  };

  Table.prototype.listenWindowResize = function listenWindowResize() {
    var _this5 = this;

    return (0, _addEventListener2["default"])(window, 'resize', function () {
      _this5.checkRightFixed();
      _this5.resizeColumns();
      clearTimeout(_this5.adjustFixedTimer);
      _this5.adjustFixedTimer = setTimeout(function () {
        if (_this5.bodyFixed) {
          _this5.bodyFixed.adjustMultilineFixedRowHeight();
        }
        if (_this5.bodyRightFixed) {
          _this5.bodyRightFixed.adjustMultilineFixedRowHeight();
        }
      }, 200);
    });
  };

  Table.prototype.onPageChange = function onPageChange(current) {
    var me = this;
    me.setState({
      currentPage: current
    }, function () {
      me.fetchData('pagination');
    });
  };

  Table.prototype.processColumn = function processColumn(props) {
    var actualProps = props || this.props;

    var me = this;
    var columns = (0, _cloneDeep2["default"])(actualProps.jsxcolumns);
    var hasCheckboxColumn = false;
    this.hasPercentWidth = false;
    for (var i = 0; i < columns.length; i++) {
      var item = columns[i];
      // only one rowSelector can be rendered in Table.
      if (item.type === 'checkbox' || item.type === 'radioSelector' || item.type === 'checkboxSelector') {
        if (item.type === 'checkbox') {
          console.warn("rowSelector using 'type: checkbox' is deprecated," + " use 'type: checkboxSelector' instead.");
        }
        hasCheckboxColumn = true;
        me.checkboxColumn = item;
        me.checkboxColumnKey = item.dataKey;
        item.width = item.width || (/kuma-uxtable-border-line/.test(actualProps.className) ? '40px' : '32px');
        item.align = item.align || 'left';
      }
      if (item.type === 'money') {
        item.align = item.align || 'right';
        item.delimiter = item.delimiter || ',';
      }
      if (/\d+%/.test('' + item.width)) {
        this.hasPercentWidth = true;
        if (this.root) {
          var scrollBarWidth = _util2["default"].measureScrollbar();
          var tableWidth = this.root.clientWidth - scrollBarWidth;
          item.width = parseFloat(item.width) * tableWidth / 100;
        }
      }
    }
    // filter the column which has a dataKey 'jsxchecked' & 'jsxtreeIcon'
    // filter the column whose dataKey is rowGroupKey

    columns = columns.filter(function (item) {
      return item.dataKey === undefined || item.dataKey !== 'jsxchecked' && item.dataKey !== 'jsxtreeIcon' && item.dataKey !== actualProps.rowGroupKey;
    });

    if (!!actualProps.rowSelection && !hasCheckboxColumn) {
      me.checkboxColumn = {
        dataKey: 'jsxchecked',
        width: /kuma-uxtable-border-line/.test(actualProps.className) ? '40px' : '32px',
        type: actualProps.rowSelector,
        align: 'right'
      };
      me.checkboxColumnKey = 'jsxchecked';
      columns = [me.checkboxColumn].concat(columns);
    } else if (actualProps.parentHasCheckbox) {
      // no rowSelection but has parentHasCheckbox, render placeholder
      columns = [{
        dataKey: 'jsxwhite',
        width: /kuma-uxtable-border-line/.test(actualProps.className) ? '40px' : '32px',
        type: 'empty'
      }].concat(columns);
    }
    if ((actualProps.subComp || actualProps.renderSubComp) && actualProps.renderModel !== 'tree' && !this.hasFixed) {
      columns = [{
        dataKey: 'jsxtreeIcon',
        width: '36px',
        type: 'treeIcon'
      }].concat(columns);
    } else if (actualProps.passedData) {
      // no subComp but has passedData, means sub mode, parent should has tree icon,
      // render tree icon placeholder
      columns = [{
        dataKey: 'jsxwhite',
        width: '34px',
        type: 'empty'
      }].concat(columns);
    }
    return columns;
  };

  Table.prototype.resizeColumns = function resizeColumns() {
    if (this.hasPercentWidth && this.root && this.root.clientWidth !== this.rootWidth) {
      this.rootWidth = this.root.clientWidth;
      this.setState({
        columns: this.processColumn()
      });
    }
  };

  Table.prototype.selectAll = function selectAll(checked) {
    var me = this;
    var content = (0, _cloneDeep2["default"])(me.state.data);
    var data = content.datas || content.data;
    var rowSelection = me.props.rowSelection;

    var selectedRows = [];
    for (var i = 0; i < data.length; i++) {
      var column = me.checkboxColumn;
      var key = me.checkboxColumnKey;
      var item = data[i];
      if ((!('isDisable' in column) || !column.isDisable(item)) && !column.disable && !((typeof rowSelection === 'undefined' ? 'undefined' : _typeof(rowSelection)) === 'object' && rowSelection.isDisabled && rowSelection.isDisabled(item))) {
        item[key] = checked;
        selectedRows.push(item);
      }
    }

    if (!!rowSelection && !!rowSelection.onSelectAll) {
      rowSelection.onSelectAll.apply(null, [checked, checked ? selectedRows : []]);
    }
    me.setState({
      data: content
    });
  };

  Table.prototype.hasFooter = function hasFooter() {
    return this.props.showFooter && typeof this.props.footer === 'function';
  };

  Table.prototype.renderTbody = function renderTbody(renderBodyProps, bodyHeight, fixedColumn) {
    var isFixedTable = ['fixed', 'rightFixed'].indexOf(fixedColumn) !== -1;
    return _react2["default"].createElement(
      'div',
      {
        className: (0, _classnames3["default"])('kuma-uxtable-body-wrapper', {
          'kuma-uxtable-fixed-body-wrapper': isFixedTable
        })
      },
      _react2["default"].createElement(_Tbody2["default"], _extends({}, renderBodyProps, {
        fixedColumn: fixedColumn,
        onScroll: this.handleBodyScroll,
        ref: _util2["default"].saveRef('body' + (0, _upperFirst2["default"])(fixedColumn), this)
      })),
      !isFixedTable ? _react2["default"].createElement(
        _uxcoreAnimate2["default"],
        { showProp: 'visible', transitionName: 'tableMaskFade' },
        _react2["default"].createElement(_Mask2["default"], { visible: this.state.showMask, text: this.props.loadingText })
      ) : null
    );
  };

  Table.prototype.renderHeader = function renderHeader(renderHeaderProps, fixedColumn) {
    if (!this.props.showHeader) {
      return null;
    }
    return _react2["default"].createElement(
      'div',
      { className: 'kuma-uxtable-header-wrapper' },
      _react2["default"].createElement(_Header2["default"], _extends({}, renderHeaderProps, {
        fixedColumn: fixedColumn,
        ref: _util2["default"].saveRef('header' + (0, _upperFirst2["default"])(fixedColumn), this),
        onScroll: this.handleHeaderScroll
      }))
    );
  };

  Table.prototype.renderFooter = function renderFooter() {
    var _this6 = this;

    var renderFooterProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var fixedColumn = arguments[1];

    if (!this.hasFooter()) {
      return null;
    }
    return _react2["default"].createElement(
      'div',
      { className: 'kuma-uxtable-footer-wrapper' },
      _react2["default"].createElement(_Footer2["default"], _extends({}, renderFooterProps, {
        fixedColumn: fixedColumn,
        ref: _util2["default"].saveRef('footer' + (0, _upperFirst2["default"])(fixedColumn), this),
        onScroll: function onScroll(scrollLeft) {
          _this6.handleFooterScroll(scrollLeft);
        }
      }))
    );
  };

  Table.prototype.renderPager = function renderPager() {
    var me = this;
    var _me$state = me.state,
        data = _me$state.data,
        currentPage = _me$state.currentPage,
        pageSize = _me$state.pageSize;
    var _me$props = me.props,
        showPagerTotal = _me$props.showPagerTotal,
        showPager = _me$props.showPager,
        locale = _me$props.locale,
        pagerSizeOptions = _me$props.pagerSizeOptions,
        isMiniPager = _me$props.isMiniPager,
        showPagerSizeChanger = _me$props.showPagerSizeChanger,
        showPagerQuickJumper = _me$props.showPagerQuickJumper,
        showUnknownTotalPager = _me$props.showUnknownTotalPager;


    if (showPager && data) {
      var pagersProps = {
        className: (0, _classnames3["default"])({
          mini: isMiniPager
        }),
        ref: _util2["default"].saveRef('pager', me),
        locale: locale,
        showSizeChanger: showPagerSizeChanger,
        showQuickJumper: showPagerQuickJumper,
        showTotal: showPagerTotal,
        total: data.totalCount,
        onShowSizeChange: me.handleShowSizeChange.bind(me),
        onChange: me.onPageChange.bind(me),
        current: currentPage,
        pageSize: pageSize,
        sizeOptions: pagerSizeOptions
      };
      var pager = _react2["default"].createElement(
        'div',
        { className: 'kuma-uxtable-page' },
        _react2["default"].createElement(_uxcorePagination2["default"], pagersProps)
      );
      if (data.totalCount) {
        if (parseInt(data.totalCount, 10) <= parseInt(pageSize, 10) && !showPagerSizeChanger) {
          return null;
        }
        return pager;
      } else if (showUnknownTotalPager) {
        return pager;
      }
    }
    return null;
  };

  Table.prototype.renderMainTable = function renderMainTable(_ref) {
    var renderHeaderProps = _ref.renderHeaderProps,
        renderBodyProps = _ref.renderBodyProps,
        renderFooterProps = _ref.renderFooterProps,
        bodyHeight = _ref.bodyHeight;
    var prefixCls = this.props.prefixCls;

    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-main-table', ref: _util2["default"].saveRef('mainTable', this) },
      this.renderHeader(renderHeaderProps, 'scroll'),
      this.renderTbody(renderBodyProps, bodyHeight, 'scroll'),
      this.renderFooter(renderFooterProps, 'scroll')
    );
  };

  Table.prototype.renderLeftFixedTable = function renderLeftFixedTable(_ref2) {
    var renderHeaderProps = _ref2.renderHeaderProps,
        renderBodyProps = _ref2.renderBodyProps,
        renderFooterProps = _ref2.renderFooterProps,
        bodyHeight = _ref2.bodyHeight;

    if (!this.hasFixed || !this.hasFixed.hasLeft || !renderBodyProps.data || !renderBodyProps.data.length) {
      return null;
    }
    var prefixCls = this.props.prefixCls;

    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-left-fixed-table', ref: _util2["default"].saveRef('fixedTable', this) },
      this.renderHeader(renderHeaderProps, 'fixed'),
      this.renderTbody(renderBodyProps, bodyHeight, 'fixed'),
      this.renderFooter(renderFooterProps, 'fixed')
    );
  };

  Table.prototype.renderRightFixedTable = function renderRightFixedTable(_ref3) {
    var renderHeaderProps = _ref3.renderHeaderProps,
        renderBodyProps = _ref3.renderBodyProps,
        renderFooterProps = _ref3.renderFooterProps,
        bodyHeight = _ref3.bodyHeight;

    if (!this.hasFixed || !this.hasFixed.hasRight || !renderBodyProps.data || !renderBodyProps.data.length) {
      return null;
    }
    var prefixCls = this.props.prefixCls;

    return _react2["default"].createElement(
      'div',
      { className: prefixCls + '-right-fixed-table', ref: _util2["default"].saveRef('rightFixedTable', this) },
      this.renderHeader(renderHeaderProps, 'rightFixed'),
      this.renderTbody(renderBodyProps, bodyHeight, 'rightFixed'),
      this.renderFooter(renderFooterProps, 'rightFixed')
    );
  };

  Table.prototype.renderActionBar = function renderActionBar() {
    var shouldRenderActionBar = function shouldRenderActionBar(config) {
      var shouldRenderAction = false;
      if (config.actionBar) {
        if (Array.isArray(config.actionBar)) {
          if (config.actionBar.length) {
            shouldRenderAction = true;
          }
        } else if (_typeof(config.actionBar) === 'object') {
          shouldRenderAction = true;
        }
      }
      var shouldRender = shouldRenderAction || config.linkBar && config.linkBar.length || config.showSearch || config.showColumnPicker;
      return shouldRender;
    };

    if (shouldRenderActionBar(this.props)) {
      var renderActionProps = {
        actionBarConfig: this.props.actionBar,
        showColumnPicker: this.props.showColumnPicker,
        locale: this.props.locale,
        linkBar: this.props.linkBar,
        checkboxColumnKey: this.checkboxColumnKey,
        showSearch: this.props.showSearch,
        searchBarPlaceholder: this.props.searchBarPlaceholder,
        columns: this.state.columns,
        width: this.props.width,
        onSearch: this.handleActionBarSearch,
        handleColumnPickerChange: this.handleColumnPickerChange,
        key: 'grid-actionbar'
      };
      return _react2["default"].createElement(_ActionBar2["default"], renderActionProps);
    }
    return null;
  };

  Table.prototype.render = function render() {
    var _this7 = this,
        _classnames;

    var me = this;
    var props = this.props,
        state = this.state;
    // if table is in sub mode, people always want to align the parent
    // and the sub table, so width should not be cared.

    var headerHeight = props.headerHeight;

    var data = state.data ? state.data.datas || state.data.data : [];
    var checkStatus = me.getCheckStatus(data);

    var style = {
      width: props.passedData ? 'auto' : props.width,
      height: props.height
    };
    var actionBarHeight = props.actionBar || props.showSearch ? props.actionBarHeight : 0;
    var pagerHeight = props.showPager && this.state.data && this.state.data.totalCount ? 67 : 0;

    // decide whether the table has column groups
    var hasGroup = false;
    for (var i = 0; i < this.state.columns.length; i++) {
      if ('group' in this.state.columns[i]) {
        hasGroup = true;
        break;
      }
    }

    var bodyHeight = void 0;
    if (props.height === 'auto' || props.height === '100%') {
      bodyHeight = props.height;
    } else {
      bodyHeight = parseInt(props.height, 10) - (headerHeight || (hasGroup ? 100 : 50)) - actionBarHeight - pagerHeight;
    }

    var commonProps = {
      columns: state.columns,
      width: props.width,
      mode: props.mode,
      renderModel: props.renderModel,
      checkboxColumnKey: me.checkboxColumnKey
    };

    var renderBodyProps = _extends({}, commonProps, {
      mask: state.showMask,
      expandedKeys: state.expandedKeys,
      currentHoverRow: state.currentHoverRow,
      rowGroupActiveKey: state.rowGroupActiveKey,
      data: data,
      bodyHeight: bodyHeight,
      hasFooter: this.hasFooter(),
      rowSelection: props.rowSelection,
      addRowClassName: props.addRowClassName,
      locale: props.locale,
      emptyText: props.emptyText,
      renderSubComp: this.hasFixed ? null : props.renderSubComp,
      rowHeight: props.rowHeight,
      loadingText: props.loadingText,
      height: bodyHeight,
      levels: props.levels,
      rowGroupKey: props.rowGroupKey,
      footer: props.footer,
      showRowGroupFooter: props.showRowGroupFooter,
      root: this,
      onCollapseChange: function onCollapseChange(activeKey) {
        _this7.setState({ rowGroupActiveKey: activeKey });
      },
      changeSelected: this.changeSelected,
      handleDataChange: this.handleDataChange,
      attachCellField: this.attachCellField,
      detachCellField: this.detachCellField,
      key: 'table-body'
    });
    var renderHeaderProps = _extends({}, commonProps, {
      activeColumn: state.activeColumn,
      orderType: state.orderType,
      showHeaderBorder: props.showHeaderBorder,
      headerHeight: props.headerHeight,
      checkStatus: checkStatus,
      selectAll: this.selectAll,
      orderColumnCB: this.handleOrderColumnCB,
      key: 'table-header'
    });

    var renderFooterProps = _extends({}, commonProps, {
      data: data,
      footer: props.footer
    });

    var config = { renderHeaderProps: renderHeaderProps, renderBodyProps: renderBodyProps, renderFooterProps: renderFooterProps, bodyHeight: bodyHeight };

    return _react2["default"].createElement(
      'div',
      {
        className: (0, _classnames3["default"])((_classnames = {}, _defineProperty(_classnames, props.prefixCls, true), _defineProperty(_classnames, props.prefixCls + '-' + props.size + '-size', true), _defineProperty(_classnames, props.className, !!props.className), _defineProperty(_classnames, 'kuma-subgrid-mode', !!props.passedData), _defineProperty(_classnames, props.prefixCls + '-tree-mode', props.renderModel === 'tree'), _defineProperty(_classnames, props.prefixCls + '-row-group-mode', !!props.rowGroupKey), _defineProperty(_classnames, props.prefixCls + '__no-data', data.length === 0), _defineProperty(_classnames, props.prefixCls + '__has-footer', this.hasFooter()), _classnames)),
        style: style,
        ref: _util2["default"].saveRef('root', this)
      },
      this.renderActionBar(),
      _react2["default"].createElement(
        'div',
        {
          className: 'kuma-uxtable-content',
          style: {
            width: props.passedData ? 'auto' : props.width
          }
        },
        this.renderMainTable(config),
        this.renderLeftFixedTable(config),
        this.renderRightFixedTable(config)
      ),
      this.renderPager()
    );
  };

  return Table;
}(_react2["default"].Component);

Table.defaultProps = {
  prefixCls: 'kuma-uxtable',
  jsxcolumns: [],
  locale: 'zh-cn',
  size: 'middle',
  showHeader: true,
  showFooter: true,
  showRowGroupFooter: false,
  width: 'auto',
  height: 'auto',
  mode: _uxcoreConst2["default"].MODE.EDIT,
  renderModel: '',
  levels: 0,
  actionBarHeight: 54,
  fetchDataOnMount: true,
  doubleClickToEdit: true,
  rowSelector: 'checkboxSelector',
  showPager: true,
  isMiniPager: false,
  showPagerSizeChanger: true,
  showPagerQuickJumper: true,
  showColumnPicker: false,
  showHeaderBorder: false,
  showPagerTotal: true,
  showMask: false,
  showSearch: false,
  getSavedData: true,
  pageSize: 10,
  pagerSizeOptions: [10, 20, 30, 40],
  rowHeight: 76,
  fetchParams: {},
  currentPage: 1,
  searchBarPlaceholder: '搜索表格内容',
  loadingText: 'loading',
  fitResponse: function fitResponse(response) {
    return {
      content: response.content,
      success: response.success === undefined ? !response.hasError : response.success,
      error: {
        message: response.content || response.errors
      }
    };
  },
  processData: function processData(data) {
    return data;
  },
  beforeFetch: function beforeFetch(obj) {
    return obj;
  },
  onFetchError: function onFetchError(err) {
    if (err && err.stack) {
      console.error(err.stack);
    }
  },
  addRowClassName: function addRowClassName() {},
  onChange: function onChange() {},
  onSave: function onSave() {},
  shouldResetExpandedKeys: function shouldResetExpandedKeys() {}
};

// http://facebook.github.io/react/docs/reusable-components.html
Table.propTypes = {
  prefixCls: _propTypes2["default"].string,
  locale: _propTypes2["default"].string,
  size: _propTypes2["default"].oneOf(['small', 'middle']),
  jsxcolumns: _propTypes2["default"].arrayOf(_propTypes2["default"].object),
  width: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].number]),
  height: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].number]),
  headerHeight: _propTypes2["default"].number,
  pageSize: _propTypes2["default"].number,
  queryKeys: _propTypes2["default"].array,
  fetchDataOnMount: _propTypes2["default"].bool,
  doubleClickToEdit: _propTypes2["default"].bool,
  showColumnPicker: _propTypes2["default"].bool,
  showPager: _propTypes2["default"].bool,
  showFooter: _propTypes2["default"].bool,
  showRowGroupFooter: _propTypes2["default"].bool,
  isMiniPager: _propTypes2["default"].bool,
  showPagerTotal: _propTypes2["default"].bool,
  showPagerQuickJumper: _propTypes2["default"].bool,
  pagerSizeOptions: _propTypes2["default"].array,
  showHeader: _propTypes2["default"].bool,
  showMask: _propTypes2["default"].bool,
  showSearch: _propTypes2["default"].bool,
  searchBarPlaceholder: _propTypes2["default"].string,
  loadingText: _propTypes2["default"].string,
  subComp: _propTypes2["default"].element,
  emptyText: _propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].element, _propTypes2["default"].object]),
  jsxdata: _propTypes2["default"].object,
  fetchUrl: _propTypes2["default"].string,
  fetchParams: _propTypes2["default"].object,
  currentPage: _propTypes2["default"].number,
  rowSelector: _propTypes2["default"].string,
  actionBar: _propTypes2["default"].oneOfType([_propTypes2["default"].array, _propTypes2["default"].object]),
  linkBar: _propTypes2["default"].oneOfType([_propTypes2["default"].array, _propTypes2["default"].object]),
  fitResponse: _propTypes2["default"].func,
  processData: _propTypes2["default"].func,
  beforeFetch: _propTypes2["default"].func,
  onFetchError: _propTypes2["default"].func,
  onColumnPick: _propTypes2["default"].func,
  addRowClassName: _propTypes2["default"].func,
  shouldResetExpandedKeys: _propTypes2["default"].func,
  passedData: _propTypes2["default"].object,
  getSavedData: _propTypes2["default"].bool,
  onChange: _propTypes2["default"].func,
  renderModel: _propTypes2["default"].string,
  levels: _propTypes2["default"].number,
  footer: _propTypes2["default"].func
};

Table.displayName = 'Table';
Table.CellField = _uxcoreCellField2["default"];
Table.Constants = _uxcoreConst2["default"];
Table.createCellField = createCellField;

exports["default"] = Table;
module.exports = exports['default'];