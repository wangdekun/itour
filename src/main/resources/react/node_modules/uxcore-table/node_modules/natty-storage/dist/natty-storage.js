(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("nattyStorage", [], factory);
	else if(typeof exports === 'object')
		exports["nattyStorage"] = factory();
	else
		root["nattyStorage"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

'use strict';

module.exports = __webpack_require__(1);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _require = __webpack_require__(2);

var extend = _require.extend;
var isPlainObject = _require.isPlainObject;
var isObject = _require.isObject;
var noop = _require.noop;

var VERSION = undefined;
(VERSION = "1.1.2");

var NULL = null;
var EMPTY = '';
var TRUE = true;
var FALSE = !TRUE;
var PLACEHOLDER = '_placeholder';
var UNDEFINED = undefined;

// 只是判断有没有`storage`对象, 注意, 有了也不一定能用!!! 比如隐身模式
var has = {
    localStorage: typeof localStorage === 'object',
    sessionStorage: typeof sessionStorage === 'object'
};

// 真正判断能不能用
var support = {
    localStorage: test('localStorage'),
    sessionStorage: test('sessionStorage'),
    variable: TRUE
};

// 能力测试
function test(type) {
    if (!has[type]) {
        return FALSE;
    }
    var data = { 'x': 'x' };
    var key = 'natty-storage-test';
    var tester = createStorage(type);
    try {
        tester.set(key, data);
        var useable = JSON.stringify(tester.get(key)) === JSON.stringify(data);
        tester.remove(key);
        return useable;
    } catch (e) {
        return false;
    }
}

// 全局默认配置
var defaultGlobalConfig = {
    // localStorage, sessionStorage, variable
    type: 'localStorage',

    // 存到浏览器缓存中使用的键
    key: EMPTY,

    // 版本号
    tag: EMPTY,

    // 有效期长, 单位ms
    duration: 0,

    // 有效期至, 时间戳
    until: 0,

    // 是否以异步方式使用set/get/has/remove
    async: false
};

/**
 *  let ls = new nattyStorage({
 *     type: 'localstorage', // sessionstorage, variable
 *       key: 'city',
 *       // 验证是否有效，如果是首次创建该LS，则不执行验证
 *       tag: '1.0'
 *  })
 */

var Storage = (function () {
    /**
     * 构造函数
     * @param options
     */

    function Storage() {
        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

        _classCallCheck(this, Storage);

        var t = this;

        t.config = extend({}, defaultGlobalConfig, options);

        // 必须配置`key`!!! 无论什么类型!!!
        if (!t.config.key) {
            throw new Error('`key` is required when using natty-storage!');
        }

        t._storage = t.config.type !== 'variable' && support[t.config.type] ? createStorage(t.config.type) : createVariable();

        t._CHECK_KEY = 'nattyStorageCheck:' + t.config.key;
        t._DATA_KEY = 'nattyStorageData:' + t.config.key;
        t._placeholderUsed = FALSE;

        // 每个`storage`实例对象都是全新的, 只有`storage`实例的数据才可能是缓存的.
        t._createStamp = +new Date();
    }

    /**
     * 惰性初始化 在首次调用`set、get、remove`方法时才执行一次 且只执行一次
     * @private
     * @note 为什么要做惰性初始化, 因为
     */

    _createClass(Storage, [{
        key: '_lazyInit',
        value: function _lazyInit() {
            var t = this;

            t._checkData = t._storage.get(t._CHECK_KEY);

            // 当前`key`的`storage`是否已经存在
            t._isNew = t._checkData === NULL;
            // console.log('is new t._checkData', t._isNew);

            // 没有对应的本地缓存 或 本地缓存已过期 则 创建新的`storage`实例
            if (t._isNew || t.isOutdated()) {
                // console.log('create new t._checkData');
                // 新的数据内容
                t._storage.set(t._DATA_KEY, t._data = {});
            }
            // 使用已有的本地缓存
            else {
                    // console.log('use cached t._checkData');
                    t._data = t._storage.get(t._DATA_KEY);
                    if (t._data === NULL) {
                        t._storage.set(t._DATA_KEY, t._data = {});
                    }
                }

            // 更新验证数据
            t._storage.set(t._CHECK_KEY, t._checkData = {
                tag: t.config.tag,
                lastUpdate: t._createStamp,
                duration: t.config.duration,
                until: t.config.until
            });
        }

        /**
         * 判断当前`key`的`storage`是否已经过期
         * @returns {boolean}
         */
    }, {
        key: 'isOutdated',
        value: function isOutdated() {
            var t = this;
            if (t.config.tag && t.config.tag !== t._checkData.tag) {
                return TRUE;
            }

            var now = +new Date();
            // 注意要使用`_checkData`的`duration`验证, 而不是用`config`的`duration`验证!!
            if (t._checkData.duration && now - t._checkData.lastUpdate > t._checkData.duration) {
                return TRUE;
            }

            if (t._checkData.until && now > t._checkData.until) {
                return TRUE;
            }

            // console.log('outdated: false');
            return FALSE;
        }

        /**
         * 设置指指定路径的数据
         * @param path {Any} optional 要设置的值的路径 或 要设置的完整值
         * @param value {Any} 值
         *
         * instance.set(object)
         * instance.set('foo', any-type)
         * instance.set('foo.bar', any-type)
         * @note ls.set('x') 则 整个值为 'x'
         */
    }, {
        key: 'set',
        value: function set(path, data) {

            var t = this;
            var argumentLength = arguments.length;

            var todo = function todo(resolve, reject) {
                try {
                    if (!t._data) {
                        t._lazyInit();
                    }

                    if (argumentLength === 1) {
                        if (isPlainObject(path)) {
                            t._data = path;
                        } else {
                            t._data[PLACEHOLDER] = path;
                            t._placeholderUsed = TRUE;
                        }
                    } else {
                        setValueByPath(path, data, t._data);
                    }

                    t._storage.set(t._DATA_KEY, t._data);
                    resolve();
                } catch (e) {
                    reject(e);
                }
            };

            if (t.config.async) {
                return new Promise(todo);
            } else {
                todo(noop, throwError);
            }
        }

        /**
         * 获取指定的路径的数据
         * @param path {String} optional 要获取的值的路径 如果不传 则返回整体值
         * @returns {ny}
         *
         * instance.get()
         * instance.get('foo')
         * instance.get('foo.bar')
         */
    }, {
        key: 'get',
        value: function get(path) {
            var t = this;
            var data = undefined;
            var todo = function todo(resolve, reject) {
                try {
                    if (!t._data) {
                        t._lazyInit();
                    }

                    if (path) {
                        data = getValueByPath(path, t._data);
                    } else if (t._placeholderUsed) {
                        data = t._data[PLACEHOLDER];
                    } else {
                        data = t._data;
                    }
                    resolve(data);
                } catch (e) {
                    reject(e);
                }
            };

            if (t.config.async) {
                return new Promise(todo);
            } else {
                todo(noop, throwError);
                return data;
            }
        }

        /**
         * 返回指定的路径是否有值
         * @param path {String} optional 要查询的路径
         * @returns {Promise}
         */
    }, {
        key: 'has',
        value: function has(path) {
            var t = this;
            var result = undefined;
            var todo = function todo(resolve, reject) {
                try {
                    if (!t._data) {
                        t._lazyInit();
                    }

                    // 如果有数据 且 没有使用内置`placeholder`, 说明是使用`path`方式设置的值
                    if (!t._placeholderUsed && !isEmptyPlainObject(t._data)) {
                        if (!path) {
                            throw new Error('a `path` argument should be passed into the `has` method');
                        }

                        result = hasValueByPath(path, t._data) ? {
                            has: true,
                            value: getValueByPath(path, t._data)
                        } : {};

                        resolve(result);
                    } else {
                        result = t._data.hasOwnProperty(PLACEHOLDER) ? {
                            has: true,
                            value: t._data[PLACEHOLDER]
                        } : {};
                        resolve(result);
                    }
                } catch (e) {
                    reject(e);
                }
            };

            if (t.config.async) {
                return new Promise(todo);
            } else {
                todo(noop, throwError);
                return result;
            }
        }

        /**
         * 删除指定的路径的数据, 包括键本身
         * @param path {String} optional 要获取的值的路径 如果不传 则返回整体值
         */
    }, {
        key: 'remove',
        value: function remove(path) {
            var t = this;
            var todo = function todo(resolve, reject) {
                try {
                    if (!t._data) {
                        t._lazyInit();
                    }
                    if (path) {
                        removeKeyAndValueByPath(path, t._data);
                        t._storage.set(t._DATA_KEY, t._data);
                    } else {
                        // 删除所有数据, 复原到初始空对象
                        t.set({});
                    }
                    resolve();
                } catch (e) {
                    reject(e);
                }
            };

            if (t.config.async) {
                return new Promise(todo);
            } else {
                todo(noop, throwError);
            }
        }

        /**
         * 销毁当前`storage`实例
         */
    }, {
        key: 'destroy',
        value: function destroy() {
            var t = this;
            t._storage.remove(t._CHECK_KEY);
            t._storage.remove(t._DATA_KEY);
        }
    }, {
        key: 'dump',
        value: function dump() {
            var t = this;
            if (!t._data) {
                t._lazyInit();
            }

            if (JSON && console) {
                console.log(JSON.stringify(this._data, NULL, 4));
            }
        }
    }]);

    return Storage;
})();

function throwError(e) {
    throw new Error(e);
}

function createStorage(storage) {
    //  不用担心这个window, 这个函数能调用, 说明已经是在浏览器端了
    storage = window[storage];
    // storage = storage === 'localStorage' ? localStorage : sessionStorage;
    return {
        // NOTE  值为undefined的情况, JSON.stringify方法会将键删除
        // JSON.stringify({x:undefined}) === "{}"
        set: function set(key, value) {
            // TODO 看看safari是否还有bug
            // storage.removeItem(key);
            storage.setItem(key, JSON.stringify(value));
        },
        get: function get(key) {
            var value = storage.getItem(key);
            // alert(localStorage[key]);
            if (!value) return NULL;
            try {
                value = JSON.parse(value);
            } catch (e) {}
            return value;
        },
        remove: function remove(key) {
            storage.removeItem(key);
        }
    };
}

var variable = {};
function createVariable() {
    var storage = variable;
    return {
        set: function set(key, value) {
            storage[key] = value;
        },
        get: function get(key) {
            // 当对应的键不存在时, 返回值保持和`storage`一致。
            if (!(key in storage)) {
                return NULL;
            }
            return storage[key];
        },
        remove: function remove(key) {
            delete storage[key];
        }
    };
}

function reserveString(str) {
    return str.split(EMPTY).reverse().join(EMPTY);
}

function splitPathToKeys(path) {
    var ret;
    if (path.indexOf('\\.') === -1) {
        ret = path.split('.');
    } else {
        ret = reserveString(path).split(/\.(?!\\)/).reverse();
        for (var i = 0, l = ret.length; i < l; i++) {
            ret[i] = reserveString(ret[i].replace(/\.\\/g, '.'));
        }
    }
    return ret;
}

function setValueByPath(path, value, data) {
    var keys = splitPathToKeys(path);
    var bottomData = data;
    while (keys.length) {
        var key = keys.shift();
        if (keys.length) {
            bottomData[key] = bottomData[key] || {};
            bottomData = bottomData[key];
        } else {
            if (isPlainObject(bottomData)) {
                bottomData[key] = value;
            } else {
                throw new Error('Cannot create property `' + key + '` on non-object value, path:`' + path + '`');
            }
        }
    }
    return data;
}

function getValueByPath(path, data, isKey) {
    isKey = isKey || false;
    if (isKey === true || path.indexOf('.') === -1) {
        return data[path];
    } else {
        var keys = splitPathToKeys(path);

        while (keys.length) {
            var key = keys.shift();
            data = getValueByPath(key, data, true);

            if (typeof data !== 'object' || data === UNDEFINED) {
                if (keys.length) data = UNDEFINED;
                break;
            }
        }
        return data;
    }
}

function hasValueByPath(path, data, isKey) {
    // 首次调用, 如果没有`.`, 就是key的含义
    isKey = isKey || path.indexOf('.') === -1;
    if (isKey) {
        return data.hasOwnProperty(path);
    } else {
        var keys = splitPathToKeys(path);
        while (keys.length) {
            var key = keys.shift();
            // console.log('check key: ', key);
            var hasKey = data.hasOwnProperty(key);
            if (hasKey && keys.length) {
                data = getValueByPath(key, data, true);
                if (!isPlainObject(data)) {
                    return FALSE;
                }
            } else {
                return hasKey;
            }
        }
    }
}

function removeKeyAndValueByPath(path, data) {
    var keys = splitPathToKeys(path);
    var bottomData = data;
    while (keys.length) {
        var key = keys.shift();
        if (keys.length) {
            bottomData[key] = bottomData[key] || {};
            bottomData = bottomData[key];
        } else {
            delete bottomData[key];
        }
    }
    return data;
}

function isEmptyPlainObject(v) {
    var ret = TRUE;
    for (var i in v) {
        ret = FALSE;
        break;
    }
    return ret;
}

var nattyStorage = function nattyStorage(options) {
    return new Storage(options);
};

nattyStorage.version = VERSION;
nattyStorage._variable = variable;
nattyStorage.support = support;

module.exports = nattyStorage;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

'use strict';

var NULL = null;

/**
 * 变换两个参数的函数到多个参数
 * @param  {Function} fn 基函数
 * @return {Function} 变换后的函数
 * @demo
 *      function add(x, y) { return x+y; }
 *      add = redo(add);
 *      add(1,2,3) => 6
 */
var redo = function redo(fn) {
	return function () {
		var args = arguments;
		var ret = fn(args[0], args[1]);
		for (var i = 2, l = args.length; i < l; i++) {
			ret = fn(ret, args[i]);
		}
		return ret;
	};
};

var OBJECT = 'object';
var isObject = function isObject(v) {
	return typeof v === OBJECT && v !== NULL;
};

var isWindow = function isWindow(v) {
	return v !== NULL && v === v.window;
};

// 参考了zepto
var isPlainObject = function isPlainObject(v) {
	return v !== NULL && isObject(v) && !isWindow(v) && Object.getPrototypeOf(v) === Object.prototype;
};

var isArray = Array.isArray;
if (false) {
	if (!isArray) {
		isArray = function (v) {
			return toString.call(v) === ARRAY_TYPE;
		};
	}
}

/**
 * 对象扩展
 * @param  {Object} receiver
 * @param  {Object} supplier
 * @return {Object} 扩展后的receiver对象
 * @note 这个extend方法是定制的, 不要拷贝到其他地方用!!!
 */
var extend = function extend() {
	var receiver = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	var supplier = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	for (var key in supplier) {
		// `supplier`中不是未定义的键 都可以执行扩展
		if (supplier.hasOwnProperty(key) && supplier[key] !== undefined) {
			if (isArray(supplier[key])) {
				receiver[key] = [].concat(supplier[key]);
			} else if (isPlainObject(supplier[key])) {
				receiver[key] = extend({}, supplier[key]);
			} else {
				receiver[key] = supplier[key];
			}
		}
	}
	return receiver;
};

var noop = function noop() {};

module.exports = {
	extend: redo(extend),
	noop: noop,
	isPlainObject: isPlainObject
};

/***/ }
/******/ ])
});
;